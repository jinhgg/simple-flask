# -*- coding: utf-8 -*-
from werkzeug.contrib.securecookie import SecureCookie
from werkzeug.routing import Rule, Map
from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase
from werkzeug.exceptions import HTTPException
from werkzeug.local import LocalStack, LocalProxy


class Request(RequestBase):

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    default_mimetype = 'text/html'


class _RequestContext(object):

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(
            environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)


    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


class SimpleFlask(object):
    request_class = Request

    response_class = Response

    secret_key = 'lijinhang'

    session_cookie_name = 'session'

    def __init__(self):

        self.debug = False

        self.url_map = Map()

        self.view_functions = {}

        self.error_handlers = {}

        self.before_request_funcs = []

        self.after_request_funcs = []

    def run(self, host='localhost', port=5000, **options):
        from werkzeug.serving import run_simple

        if 'debug' in options:
            self.debug = options.pop('debug')
        # 如果debug为True，开启重载器（reloader）
        options.setdefault('use_reloader', self.debug)
        # 如果debug为True，开启调试器（debugger）
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)
    def open_session(self, request):

        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):

        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):

        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f

        return decorator

    def errorhandler(self, code):

        def decorator(f):
            self.error_handlers[code] = f
            return f

        return decorator

    def before_request(self, f):
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        self.after_request_funcs.append(f)
        return f

    def match_request(self):
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):

        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):

        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):

        return _RequestContext(self, environ)

    def __call__(self, environ, start_response):
        return self.wsgi_app(environ, start_response)


_request_ctx_stack = LocalStack()
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)

